# Глава 3. РЕАЛИЗАЦИЯ НА СИСТЕМАТА

Тази глава описва техническата реализация на хибридната архитектура на Grape. Системата е проектирана около модела "Pull-Based Agent", който позволява сигурно и асинхронно управление на отдалечени инфраструктурни ресурси чрез централизиран контролен панел.

## 3.1. Архитектурен Преглед: Хибридният Модел
*   **3.1.1. Компоненти на Системата:**
    *   **Control Plane (SaaS):** Next.js уеб портал и Supabase (Database/Auth), разположени в облака.
    *   **Execution Plane (Remote):** Grape CLI, работещ в режим "Agent" върху инфраструктурата на клиента (или локална машина).
    *   **Template Registry:** Монохранилище, съдържащо "Златните шаблони" (`packages/templates`).
*   **3.1.2. Поток на Данните:** Еднопосочен контролен поток (User -> DB -> Agent) и обратен поток на телеметрия (Agent -> DB -> User).

## 3.2. Реализация на Контролния Панел (Trigger Mechanism)
*   **3.2.1. Управление на Конфигурации (The Intent):**
    *   Съхранение на желаното състояние (JSON конфигурация) в Supabase.
*   **3.2.2. Иницииране на Деплоймънт (The Trigger):**
    *   Вместо директна комуникация с агента, Frontend-ът (или CLI в интерактивен режим) създава запис в таблица `deployments`.
    *   Payload структура: `{ id: "job-uuid", config_id: "cfg-uuid", status: "queued", cluster_id: "target-cluster" }`.

## 3.3. Реализация на "Grape Agent" (The Handshake)
*   **3.3.1. Go Binary Architecture:**
    *   Използване на Go за създаване на лек, статично компилиран агент.
*   **3.3.2. Механизъм на Опашката (The Pull Loop):**
    *   Агентът периодично (polling) или чрез Supabase Realtime слуша за нови задачи със статус `queued`, насочени към неговия `cluster_id`.
    *   Този подход елиминира нуждата от отваряне на входящи портове (Firewall/NAT traversal).
*   **3.3.3. Управление на Състоянието:**
    *   Атомарно обновяване на статуса в DB: `queued` -> `in_progress`.

## 3.4. Логика на Изпълнение (The Execution)
*   **3.4.1. Подготовка на Средата:**
    *   Изтегляне на детайлната конфигурация от Supabase.
    *   Клониране или извличане на Terraform модулите от `@packages/templates/**`.
*   **3.4.2. Оркестрация на Инструментите:**
    *   **Infracost:** Предварителен анализ на цената (ако е активиран).
    *   **Terraform:** Изпълнение на `init`, `plan` и `apply` чрез `os/exec` пакета в Go.
    *   Динамично генериране на `tfvars` на базата на изтеглената конфигурация.

## 3.5. Поточна Телеметрия (The Stream)
*   **3.5.1. Улавяне на Логове:**
    *   Прихващане на `StdoutPipe` и `StderrPipe` от Terraform процеса в реално време.
*   **3.5.2. Буфериране и Изпращане:**
    *   Агентът буферира редовете и ги изпраща на пакети (batch insert) към таблица `deployment_logs` в Supabase, за да не претовари мрежата.
*   **3.5.3. Визуализация (Frontend):**
    *   Next.js клиентът се абонира за промени (INSERT) в `deployment_logs` чрез Supabase Realtime.
    *   Ефект на "Жив Терминал" в браузъра на потребителя.

## 3.6. Инфраструктурни Шаблони (The Content)
*   **3.6.1. Структура на `@packages/templates`:**
    *   Анализ на модулите: VPC, EKS, RDS, Karpenter.
    *   Как Агентът избира кои модули да активира (`count` параметри) спрямо потребителската конфигурация.

## 3.7. Сигурност и Права за Достъп
*   **3.7.1. IAM и Роли:** Агентът използва локалните AWS credentials/roles на машината, върху която работи ("Zero-Key" трансфер към сървъра).
*   **3.7.2. Изолация:** Всеки деплоймънт е изолиран процес.

---
**Цел на главата:** Да дефинира ясно как "тънката част" (комуникацията) е решена чрез DB-driven архитектура, осигуряваща надеждност и проследимост.