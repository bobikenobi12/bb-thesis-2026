# 3.3. Реализация на Изпълнителния панел (Execution Plane - CLI)

Изпълнителният панел на платформата Grape е реализиран като CLI (Command Line Interface) инструмент, написан на езика **Go**. Той изпълнява ролята на "работник" (worker), който оркестрира целия жизнен цикъл на инфраструктурата — от извличането на конфигурациите до физическото провизиране на ресурсите.

## 3.3.1. Архитектура на Go приложението

Архитектурата на CLI инструмента е проектирана да бъде модулна и разширяема, следвайки принципите на чистия код (Clean Code) и идиоматичния Go (Idiomatic Go).

### 3.3.1.1. Командна структура с Cobra
За управление на командния интерфейс се използва библиотеката **Cobra**. Тя предоставя стабилна основа за дефиниране на команди, подкоманди и флагове.

Основната входна точка е файлът `cmd/root.go`, който инициализира корена на приложението. Всяка основна функционалност е отделена в собствен файл в пакета `cmd/` (напр. `deploy.go`, `login.go`).

```go
// Пример за дефиниция на команда в cmd/deploy.go
var deployCmd = &cobra.Command{
    Use:   "deploy [project_name]",
    Short: "Deploy a project's infrastructure",
    Run: func(cmd *cobra.Command, args []string) {
        // Логика за изпълнение
    },
}
```

### 3.3.1.2. Управление на зависимости и конфигурация
За четене на конфигурационни файлове и променливи на средата се използва **Viper** (често в тандем с Cobra). Локалната конфигурация на потребителя (като пътища до токени и настройки на профила) се съхранява в директорията `~/.grape/`.

## 3.3.2. Интерактивен потребителски интерфейс (TUI)

За да се подобри потребителското изживяване и да се намали кривата на обучение, Grape CLI внедрява богат интерактивен интерфейс в терминала (Terminal User Interface - TUI).

### 3.3.2.1. Библиотеките на Charm (Bubble Tea, Huh)
Интерфейсът е изграден с помощта на екосистемата **Charm**:
*   **Bubble Tea:** Функционален модел (The Elm Architecture) за управление на състоянието на терминала.
*   **Huh:** Библиотека за създаване на форми (forms) и "wizards" в терминала. Използва се при командата `deploy` за потвърждение на действия и избор на опции, когато не са подадени като флагове.
*   **Lipgloss:** За стилизиране на текста (цветове, рамки, отстъпи), придавайки на CLI инструмента модерен и професионален вид.

### 3.3.2.2. Визуализация на процесите
Тъй като операциите по деплоймънт могат да отнемат време, CLI предоставя визуална обратна връзка чрез "spinners" и прогрес барове. Логирането е структурирано (чрез `utils/logger.go`), като важните съобщения се оцветяват в зависимост от нивото (INFO, WARN, ERROR) и се изпращат паралелно към API-то за съхранение в историята на деплоймънтите.

## 3.3.3. Логика на "Работника" (Worker Logic)

Това е сърцето на изпълнителния панел. Тук се случва координацията между различните външни инструменти (Git, Terraform, Helm, Kubernetes).

### 3.3.3.1. Git Оркестрация (`pkg/git`)
Пакетът `git` (в `apps/cli/git/git.go`) предоставя абстракция над библиотеката `go-git`. Той управлява целия поток на кода:
1.  **Клониране на Шаблони:** Изтегля "Златните шаблони" (Golden Templates) от централното хранилище (`@repo/templates`).
2.  **Bootstrap:** Инициализира новото клиентско хранилище, копирайки необходимите файлове, но игнорирайки специфичните за Git метаданни.
3.  **Commit & Push:** Автоматично добавя (stage), комитва и изпраща (push) генерираните конфигурации към хранилището на клиента.
4.  **Обработка на грешки:** Включва логика за справяне с празни или несъществуващи хранилища, като предлага на потребителя автоматичното им създаване чрез API-то.

### 3.3.3.2. Terraform Wrapper (`pkg/terraform`)
Вместо да разчита потребителят да изпълнява ръчно команди, Grape CLI действа като обвивка (wrapper) около Terraform бинарния файл.
*   **Init & Plan:** Инициализира работната директория и генерира план за изпълнение, който се записва във файл.
*   **Infracost Интеграция:** Преди прилагане, планът се анализира от Infracost (ако е наличен токен), за да се предостави прогноза за месечните разходи.
*   **Apply:** Изпълнява промените, като пренасочва `stdout` и `stderr` към логера на приложението за реално време визуализация.
*   **Outputs:** Извлича резултатите (outputs) след успешно изпълнение, за да ги използва в следващите стъпки (напр. името на EKS клъстера).

### 3.3.3.3. Генератор на Шаблони (Template Engine)
За динамичното попълване на конфигурационните файлове (като `terraform.tfvars` и Kubernetes манифести) се използва **Pongo2** - Go имплементация на Django-syntax шаблонираща система.
*   **Контекст:** Данните от конфигурацията (AWS регион, име на проект, CIDR блокове) се подават като контекст към шаблоните.
*   **Рендериране:** Pongo2 заменя променливите (напр. `{{ region }}`) с техните стойности преди запис във файловата система.

### 3.3.3.4. Helm и Kubernetes Клиенти
За финалната фаза (GitOps bootstrapping), CLI използва:
*   **Helm SDK:** За програмно инсталиране и обновяване на ArgoCD чартове.
*   **Kubernetes Client-Go:** За прилагане на манифести (напр. "App of Apps") директно в клъстера.
*   **AWS SDK:** За създаване на S3 кофи за Terraform state и удостоверяване пред EKS.

## 3.3.4. Сигурност и Автентикация

Сигурността е критичен аспект, тъй като CLI инструментът оперира с чувствителна инфраструктура.

### 3.3.4.1. Device Flow (OAuth 2.0)
Автентикацията следва стандарта **Device Authorization Grant** (RFC 8628), идеален за устройства с ограничени входни възможности или CLI инструменти.
1.  CLI изисква код от сървъра.
2.  Потребителят сканира QR код или отваря URL, за да потвърди входа в браузъра си (където вече е логнат в Next.js приложението).
3.  CLI "полва" (polls) сървъра до получаване на Access и Refresh токени.

### 3.3.4.2. Локално съхранение на Токени
Токените се съхраняват в JSON файл (`config.json`) в домашната директория на потребителя, защитени чрез права за достъп до файловата система (0600). При всяка команда CLI проверява валидността на токена и при необходимост използва Refresh токена за обновяване на сесията, без да прекъсва работата на потребителя.

### 3.3.4.3. "Zero-Key" достъп до AWS
Grape CLI не съхранява дългосрочни AWS Access Keys. Вместо това, той разчита на конфигурирани AWS профили (`~/.aws/credentials`) или SSO сесии, като използва `aws-profile` флага за избор на идентичност. Това гарантира, че компрометирането на CLI конфигурацията не води до директна загуба на облачни права.
