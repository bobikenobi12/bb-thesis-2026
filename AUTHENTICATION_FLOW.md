# CLI Authentication Architecture: The "Copy-Paste" Flow

## 1. Overview
This document outlines the authentication flow for a Go-based CLI tool (built with Cobra and Charm) authenticating against a Next.js web application (hosted on Vercel) using Supabase Auth.

**The Goal:** securely transfer a Supabase Session (Access/Refresh Tokens) from an authenticated web browser to the CLI.

**The Route:** `https://yoursite.com/dashboard/cli/login?device_code=<CLI_GENERATED_ID>`

---

## 2. Actors & Terminology

1.  **CLI (Go/Cobra):** The client application requiring authentication.
2.  **Vercel API (Backend):** Serverless functions acting as the secure bridge.
3.  **Supabase (Auth/DB):** Identity provider and temporary state storage.
4.  **Device Code:** A unique, random ID (UUID or Hex) generated by the CLI to track the specific login session.
5.  **Verification Code:** A short, human-readable code (e.g., `C8J-9KK`) generated by the Backend for the user to type.

---

## 3. Database Schema
We need a temporary table in Supabase to bridge the gap between the browser session and the CLI.

```sql
create table cli_logins (
  device_code uuid primary key,         -- The ID generated by the CLI
  profile_id uuid references profiles(id) on DELETE CASCADE,   -- Populated after user logs in on web
  verification_code text,               -- The short code the user types into CLI
  refresh_token text,                   -- The token to be passed to CLI
  created_at timestamptz default now(),
  expires_at timestamptz default (now() + interval '10 minutes')
);

-- RLS: Only Service Role (Vercel) should read/delete. 
-- Authenticated users (Web) can only update their specific row if they know the device_code.
alter table cli_logins enable row level security;
```

--- 
## 4. 

1. **Phase A**: Initiation (CLI)
User runs grape login.

CLI generates a UUID v4. This is the device_code.

CLI prints: "Please visit: https://yoursite.com/dashboard/cli/login?device_code=<device_code>"

CLI transitions to a Charm/BubbleTea input model, waiting for the user to type a code.

Phase B: Web Authentication (Frontend)
User visits the link.

Next.js Page (/dashboard/cli/login) checks authentication state.

If not logged in: Redirect to Supabase Login, preserving the device_code param.

If logged in: Proceed.

Frontend calls Vercel API Endpoint: POST /api/auth/cli/generate.

Payload: { device_code, session_access_token }

Vercel API validates the user's session.

Vercel API generates a Verification Code (e.g., AB-12).

Vercel API inserts/updates into Supabase cli_logins:

device_code: from payload

verification_code: AB-12

refresh_token: user's current refresh token

user_id: user's UUID

Frontend displays the Verification Code (AB-12) to the user in big, bold text.

Phase C: Exchange (CLI)
User switches back to terminal and types AB-12 into the Charm input field.

CLI sends payload to Vercel API: POST /api/auth/cli/exchange.

Payload: { device_code, verification_code }

Vercel API:

Looks up row where device_code matches AND verification_code matches.

Checks if expires_at is valid.

Crucial Step: Uses refresh_token from DB to request a new, distinct session from Supabase (Rotation).

Deletes the row from cli_logins (One-time use).

Returns { access_token, refresh_token, user_email }.

CLI saves tokens to ~/.config/grape/credentials.json.

CLI prints success message.

---

5. Technical Implementation Specs
A. Vercel API Routes (Next.js App Router)
1. Generate (route.ts)

Path: app/api/auth/cli/generate/route.ts

Role: Authenticated endpoint.

Logic:

Verify user is logged in (Supabase Server Client).

Generate random 6-char string.

Upsert into cli_logins using supabase-admin (Service Role).

2. Exchange (route.ts)

Path: app/api/auth/cli/exchange/route.ts

Role: Public endpoint (secured by the knowledge of the codes).

Logic:

Select from cli_logins.

Validate match.

Perform supabase.auth.refreshSession({ refresh_token }).

Delete row.

Return new session.

B. Go CLI (Cobra + Charm)
Dependencies:

github.com/spf13/cobra (Command structure)

github.com/charmbracelet/bubbles/textinput (The input field)

github.com/charmbracelet/bubbletea (The TUI loop)

Logic:

Use cobra to define loginCmd.

Inside Run:

Generate UUID.

Open browser (pkg/browser).

Start bubbletea program.

The TUI is a simple View with a textinput.

On Enter key: Trigger the HTTP POST to /exchange.

Handle Spinner state during HTTP request.

On Success: Write file, Program.Quit().

6. Security & Caveats
Token Exposure: The URL contains the device_code. This is safe as it is only half the key. The attacker needs the verification_code (displayed only to the authenticated user) to hijack the session.

Race Conditions: The cli_logins table should have a unique constraint on device_code.

Expiration: The table cleans itself or is cleaned by RLS/Cron, but the strict expires_at check in the API is mandatory.

Token Isolation: The "Exchange" step must perform a session refresh. We do not want the CLI and the Browser sharing the exact same Refresh Token string, as a logout in one might invalidate the other depending on your Supabase revocation settings.